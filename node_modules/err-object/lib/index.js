"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Errors = exports.exitOnNotDefined = exports.error = void 0;

var _util = _interopRequireDefault(require("util"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var error = function error(thing) {
  var Ctor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Error;

  if (typeof thing === 'string') {
    return new Ctor(thing);
  }

  var message = thing.message,
      others = _objectWithoutProperties(thing, ["message"]);

  var error = new Ctor(message);
  Object.assign(error, others);
  return error;
};

exports.error = error;

function _factory(_ref) {
  var _ = _ref._,
      code = _ref.code,
      preset = _ref.preset,
      args = _ref.args;

  var _preset$ctor = preset.ctor,
      ctor = _preset$ctor === void 0 ? Error : _preset$ctor,
      messageTemplate = preset.message,
      others = _objectWithoutProperties(preset, ["ctor", "message"]);

  var message = typeof messageTemplate === 'function' ? messageTemplate.apply(void 0, _toConsumableArray(args)) : _util.default.format.apply(_util.default, [_(messageTemplate)].concat(_toConsumableArray(args)));
  return error(_objectSpread({}, others, {
    code: code,
    message: message,
    args: args
  }), ctor);
}

var _notDefined = function _notDefined(code) {
  var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return error({
    code: code,
    message: message
  });
};

var checkFunction = function checkFunction(subject, name) {
  if (typeof subject !== 'function') {
    throw error("".concat(name, " must be a function"), TypeError);
  }
};

var JUST_RETURN = function JUST_RETURN(s) {
  return s;
};

var exitOnNotDefined = function exitOnNotDefined(code) {
  /* istanbul ignore next */
  throw error("[err-object] code \"".concat(code, "\" is not defined"));
  /* istanbul ignore next */

  process.exit(1);
};

exports.exitOnNotDefined = exitOnNotDefined;
var BUT_GOT = ', but got `%s`';

var Errors =
/*#__PURE__*/
function () {
  function Errors() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        factory = _ref2.factory,
        notDefined = _ref2.notDefined,
        _ref2$i18n = _ref2.i18n,
        i18n = _ref2$i18n === void 0 ? JUST_RETURN : _ref2$i18n,
        prefix = _ref2.prefix,
        codePrefix = _ref2.codePrefix,
        _ref2$messagePrefix = _ref2.messagePrefix,
        messagePrefix = _ref2$messagePrefix === void 0 ? prefix : _ref2$messagePrefix;

    _classCallCheck(this, Errors);

    this._errors = Object.create(null);
    this._factory = factory || _factory;
    this._notDefined = notDefined || _notDefined;
    this._ = i18n;
    this._messagePrefix = messagePrefix;
    this._codePrefix = codePrefix;
    checkFunction(this._factory, 'factory');
    checkFunction(this._notDefined, 'notDefined');
    this.E = this.E.bind(this);
    this.TE = this.TE.bind(this);
    this.error = this.error.bind(this);
    this.i18n = this.i18n.bind(this);
  }

  _createClass(Errors, [{
    key: "i18n",
    value: function i18n(__) {
      this._ = __;
      return this;
    }
  }, {
    key: "E",
    value: function E(code) {
      var preset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var factory = arguments.length > 2 ? arguments[2] : undefined;

      if (typeof preset === 'string') {
        return this.E(code, {
          message: preset,
          ctor: factory || Error
        });
      }

      factory = factory || this._factory;

      if (this._messagePrefix && preset.message) {
        preset.message = this._messagePrefix + preset.message;
      }

      code = this._decorateCode(code);
      checkFunction(factory, 'factory');
      this._errors[code] = [preset, factory];
      return this;
    }
  }, {
    key: "TE",
    value: function TE(code, message) {
      this.E(code, message + BUT_GOT, TypeError);
      return this;
    }
  }, {
    key: "_decorateCode",
    value: function _decorateCode(code) {
      return this._codePrefix ? this._codePrefix + code : code;
    }
  }, {
    key: "error",
    value: function error(code) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      code = this._decorateCode(code);

      if (code in this._errors) {
        var _this$_errors$code = _slicedToArray(this._errors[code], 2),
            preset = _this$_errors$code[0],
            factory = _this$_errors$code[1];

        var _ = this._;
        return factory({
          _: _,
          code: code,
          preset: preset,
          args: args
        });
      }

      return this._notDefined.apply(this, [code].concat(args));
    }
  }]);

  return Errors;
}();

exports.Errors = Errors;